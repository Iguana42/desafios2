#include <bits/stdc++.h>
using namespace std;
#define int long long
using ll = long long;
// #define endl '\n'

void dbg_out() { cerr << endl; }
template<typename Head, typename... Tail> void dbg_out(Head H, Tail... T){ cerr << ' ' << H; dbg_out(T...); }
#define dbg(...) cerr<<"(" << #__VA_ARGS__<<"):" , dbg_out(__VA_ARGS__) , cerr << endl


//templete treap github do mori
static const uint64_t FIXED_RANDOM = 12341231;
std::mt19937 mt(FIXED_RANDOM);
struct treap_node {
	std::array<treap_node*, 2> c{nullptr, nullptr};
	std::mt19937::result_type pri = mt();
	int lazy = 0, lazyf = 0, flip = 0, v;
	ll soma = 0, eu = 0;
    int tamanho = 0;
	ll eu2 = 1;
	void apply(int a, int b) {
		if(b){
			swap(c[0],c[1]);
			v *= -1;
			lazy *= -1;
			lazyf ^= 1;
		}
		v += a; lazy += a;
	}
	void downdate() {
		if (lazy) {
			if (c[0]) c[0]->apply(lazy, lazyf);
			if (c[1]) c[1]->apply(lazy, lazyf);
			lazy = lazyf = 0;
		}
	}
	void update() {
        //soma de um intervalo
		soma = eu;
		if(c[0]) soma += c[0]->soma;
		if(c[1]) soma += c[1]->soma;
		//tamanho
		tamanho = eu2;
		if(c[0]) tamanho += c[0]->tamanho;
		if(c[1]) tamanho += c[1]->tamanho;
	}
};
// this code just merge if max(a) <= min(b), don't deal with complex merges
treap_node* merge(treap_node* a, treap_node* b) {
	if (!b){
		a->update();
		return a;
	}
	if (!a){
		b->update();
		return b;
	}
	treap_node* r;
	if (a->pri < b->pri) {
		r = a;
		a->downdate();
		r->c[1] = merge(a->c[1], b);
	} else {
		r = b;
		b->downdate();
		r->c[0] = merge(a, b->c[0]);
	}
	if(r) r->update(); 
	return r;
}
 
//slip da arvore com os elementos <y e >=y
std::pair<treap_node*, treap_node*> split(treap_node* r, int y) {
	if (!r) return {nullptr, nullptr};
	r->downdate();
	treap_node *a, *b;
	if (r->v >= y) {
		b = r;
		std::tie(a, b->c[0]) = split(r->c[0], y);
	} else {
		a = r;
		std::tie(a->c[1], b) = split(r->c[1], y);
	}
	if(a) a->update();
	if(b) b->update();
	return {a, b};
}
treap_node* add(treap_node* a, treap_node* node, int y, int eu){
	node->v = y;
	node->eu = eu;
	auto [l, r] = split(a, y);
	treap_node* ROOT;
	ROOT = merge(l, node);
	ROOT = merge(ROOT, r);
	return ROOT;
}
//reverte L to R, a is a tree where the keys 
//are from 1 to N, 1 <= L <= R <= N
treap_node* reverte(treap_node *a, int L, int R){
	if(!a) return a;
	int tam = R-L+1;
	treap_node*x,*y,*z;
	tie(x,y) = split(a,L);
	tie(y,z) = split(y,R+1);
	if(y && tam >= 2){
		y->apply(R+L,1);
	}
	a = merge(x,y); a = merge(a,z);
	return a;
}
treap_node* find(treap_node *a, int y){
	if(!a) return nullptr;
	a->downdate();
	treap_node* b;
	if(a->v == y){
		b = a;
	}else if(a->v < y){
		b = find(a->c[1], y);
	}else{
		b = find(a->c[0], y);
	}
	b->update();
	return b;
}

treap_node* remove(treap_node* r, int y) {
    auto [r1, r2] = split(r,y);
    auto [r3, r4] = split(r2,y+1);

	treap_node* r_final = merge(r1,r4);
    return r_final;
}

int k_th(treap_node* a, int k) {
    auto [l, r] = split(a,k);
	int tam1 = l->tamanho;
	if(k < 0) return -10000000000;
	else if(tam1 < k){
		return k_th(r,k-tam1);
	}
	else if(tam1 == k){
		return a->v;
	}
	else{
		return k_th(l,k);
	}
}
int count(treap_node* a, int x){
	auto [l, r] = split(a,x);
	return l->tamanho;
}



void solve(){
    int q;
    cin >> q;
	// dbg(q);
    treap_node* root = nullptr;
    for( int i = 0; i < q; i++){
        char c; int num;
        cin >> c >> num;
		// dbg(c,um);
        if( c == 'I'){
			// dbg("entrou1");
            if (!find(root, num)) {
				dbg("vamos inserir",num);
                root = add(root, new treap_node(), num, num);
            }
        }
        if( c == 'D'){
            if (find(root, num)) {
                root = remove(root, num);
            }
        }
        if( c == 'K'){
            int resp = k_th(root,num);
			if(resp == -10000000000)cout << "invalid" << endl;
			else cout << resp << endl;
        }
        if( c == 'C'){
            int resp = count(root, num);
			cout << resp << endl;
        }
    }
}

signed main(){
    ios_base::sync_with_stdio;
	cin.tie(0);
	// cout.tie();
    solve();
}
